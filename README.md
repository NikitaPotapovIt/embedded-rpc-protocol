# Встроенный RPC через UART для STM32F411RE

Этот проект реализует протокол **удалённого вызова процедур (RPC)** через UART, обеспечивая бесшовный вызов функций между хостом (клиентом) и устройством STM32F411RE (сервером) с использованием FreeRTOS. Проект разработан для платы **Nucleo-F411RE**, использует **C++17** с интеграцией FreeRTOS и предоставляет модульную, типобезопасную и расширяемую архитектуру.

---

## Содержание

- [Архитектурный обзор](#-архитектурный-обзор)
- [Ключевые возможности](#-ключевые-возможности)
- [Быстрый старт](#-быстрый-старт)
- [Структура проекта](#-структура-проекта)
- [Детали реализации](#-детали-реализации)
- [Анализ и улучшения протокола](#-анализ-и-улучшения-протокола)
- [Ограничения](#-ограничения)
- [Предложения по улучшению](#-предложения-по-улучшению)
- [Требования к сборке](#-требования-к-сборке)
- [Заключение](#-заключение)

---

## Архитектурный обзор

Проект реализует многоуровневый RPC-протокол через UART для надёжной и эффективной коммуникации. Архитектура разделяет функционал на уровни, обеспечивая модульность и масштабируемость.

```
┌─────────────────┐    Сериализованные данные    ┌─────────────────┐
│   Хост/Клиент   │ ◄─────────────────────────► │ Устройство/Сервер│
└─────────────────┘                           └─────────────────┘
            │                                      │
            │ Поток UART                          │ Поток UART
            ▼                                      ▼
┌─────────────────────────┐              ┌─────────────────────────┐
│ Уровень приложения      │              │ Уровень приложения      │
│  - Реестр функций       │              │  - Обработка в задачах  │
│  - Типобезопасные обёртки│             │  - Динамическая диспетчеризация │
├─────────────────────────┤              ├─────────────────────────┤
│ Транспортный уровень    │              │ Транспортный уровень    │
│  - Сериализация сообщений│             │  - Парсинг сообщений    │
│  - Запрос/Ответ         │              │  - Обработка ошибок     │
├─────────────────────────┤              ├─────────────────────────┤
│ Канальный уровень       │              │ Канальный уровень       │
│  - Формирование пакетов │              │  - Дефрейминг потока    │
│  - Проверка CRC8        │              │  - Byte-Stuffing (опц.) │
├─────────────────────────┤              ├─────────────────────────┤
│ Физический уровень      │              │ Физический уровень      │
│  - Драйвер UART (HAL)   │              │  - Асинхронный UART (IT)│
└─────────────────────────┘              └─────────────────────────┘
```

---

## Ключевые возможности

- **RPC по имени функции**: Вызов функций удалённо с использованием строковых идентификаторов (например, `add(1, 2)`).
- **Поддержка возвращаемых значений**: Результаты передаются обратно клиенту.
- **Интеграция с FreeRTOS**: Обработка запросов в выделенной задаче FreeRTOS.
- **Совместимость с FPU**: Поддержка операций с `float` через аппаратный FPU Cortex-M4F.
- **Модульная архитектура**: Разделение на протокол, RPC-логику и драйверы для удобства поддержки.
- **C++17**: Использование `std::tuple`, `std::function`, лямбда-выражений и `constexpr`.

---

## Быстрый старт

### 1. Регистрация обработчиков
Регистрируйте функции на стороне сервера для обработки входящих RPC-запросов.

```cpp
// В main.cpp
service.register_handler("add", &add);
service.register_handler("get_temperature", &get_temperature);
service.register_handler("set_led", &set_led);
```

**Примеры функций**:
```cpp
int32_t add(int32_t a, int32_t b);
float get_temperature();
void set_led(bool state);
```

### 2. Вызов удалённых функций
Вызывайте функции с клиента и получайте результаты.

```cpp
int32_t result;
if (client.call("add", std::make_tuple(5, 3), result)) {
    // Успех: result = 8
} else {
    // Ошибка: таймаут или функция не найдена
}
```

### 3. Запуск задачи обработки
Запустите цикл обработки на стороне сервера в задаче FreeRTOS.

```cpp
xTaskCreate([](void* param) {
    auto* s = static_cast<rpc::Service*>(param);
    while (true) {
        s->process();
        vTaskDelay(1); // Уступаем другим задачам
    }
}, "RPC_Service", 256, &service, 1, nullptr);
```

---

## Структура проекта

```
.
├── include/                 # Заголовочные файлы
│   ├── drivers/             # Абстракции драйверов
│   │   └── uart.hpp         # Интерфейс UART
│   ├── protocol/            # Канальный и транспортный уровни
│   │   ├── parser.hpp       # Парсер потока байт в пакеты
│   │   ├── sender.hpp       # Формирование и отправка пакетов
│   │   └── crc.hpp          # Вычисление CRC8
│   └── rpc/                 # Логика RPC
│       ├── client.hpp       # Вызов функций на стороне клиента
│       └── service.hpp      # Диспетчеризация функций на сервере
├── src/                     # Исходный код
│   ├── drivers/
│   │   └── uart.cpp         # Реализация драйвера UART (HAL)
│   ├── protocol/
│   │   ├── parser.cpp
│   │   ├── sender.cpp
│   │   └── crc.cpp
│   ├── rpc/
│   │   ├── client.cpp
│   │   └── service.cpp
│   └── main.cpp             # Точка входа
├── lib/                     # Внешние библиотеки
│   └── FreeRTOS/            # FreeRTOS с портом для ARM_CM4F
├── platformio.ini           # Конфигурация сборки PlatformIO
└── README.md                # Этот файл
```

---

## Детали реализации

### Канальный уровень: Надёжная передача
- **Формат пакета**:
  ```cpp
  // 0xFA | l_l | l_h | crc8_hdr | 0xFB | payload | crc8_full | 0xFE
  ```
- **Синхронизация**: Маркеры `0xFA`, `0xFB`, `0xFE` обеспечивают определение границ пакета.
- **Длина пакета**: 2 байта (до 65 535 байт).
- **CRC8**: Проверка целостности заголовка и всего пакета.
- **Парсер**: Конечный автомат для преобразования потока байт в пакеты.

### Транспортный уровень: Логика RPC
- **Формат сообщения**:
  ```cpp
  // type | seq | name\0 | args...
  ```
- **Типы сообщений**: `0x0B` (запрос), `0x0C` (ответ), `0x21` (ошибка).
- **Порядковый номер**: Для сопоставления запросов и ответов.
- **Имена функций**: Строки с завершающим нулем.
- **Аргументы**: Сериализуются как сырые байты.

### Интеграция с FreeRTOS
- Используется `HAL_SYSTICK_Callback()` для совместимости с `HAL_Delay()`.
- Исключено дублирование обработчиков (`vPortSVCHandler`, `xPortPendSVHandler`) — используется только `port.c`.

---

## Анализ и улучшения протокола

### Текущие ограничения
- **Отсутствие таймаута**: Клиент может зависнуть при потере ответа.
- **Поиск по строкам**: Медленный поиск с использованием `strcmp`.
- **Отсутствие проверки типов аргументов**: Риск неопределённого поведения (например, `add("hello", 5)`).
- **Слабый CRC8**: Вероятность пропуска ошибки — 1/256.
- **Отсутствие контроля потока**: Риск переполнения буфера при высокой нагрузке.
- **Блокирующий `call()`**: Может мешать другим задачам.

### Реализованные улучшения
- **Поддержка FPU**: Включена через `build_flags` и `extra_scripts` для операций с `float`.
- **Исключение дублирования обработчиков**: Удалены `SVC_Handler`, `PendSV_Handler` из `stm32f4xx_it.c`.
- **Кроссплатформенность**: Сборка на macOS, Windows и Linux через PlatformIO.
- **Подавление предупреждений**: Используется `-specs=nosys.specs` для устранения предупреждений о `_write`, `_close` и т.д.

---

## Ограничения
- **Отсутствие таймаута в `call()`**: Может блокировать задачу навсегда.
- **Поиск O(n)**: Медленный при 100+ функциях.
- **Отсутствие валидации аргументов**: Ошибки типов приводят к неопределённому поведению.
- **Ограничение размера пакета**: 64 КБ может быть недостаточно для больших данных.
- **Отсутствие поддержки массивов**: Только структуры фиксированного размера.
- **Полудуплексный UART**: Без контроля потока возможна потеря данных.

---

## Предложения по улучшению
- **Таймаут ответа**: Добавить `client.call(..., timeout_ms)` для надёжности.
- **Хеширование имён функций**: Использовать `crc16("add")` для поиска за O(1).
- **Валидация типов аргументов**: Добавить байт типа (`int32`, `float`, `bool`).
- **Асинхронные вызовы**: Реализовать `call_async(name, args, callback)`.
- **Буферизация пакетов**: Использовать очередь исходящих пакетов.
- **Усиление CRC**: Перейти на CRC16 для лучшей защиты от ошибок.
- **Поддержка потоков**: Добавить тип `0x16` для потоковых данных (например, логов).
- **Сериализация**: Использовать FlatBuffers или Cap'n Proto для структурированных данных.
- **Поддержка массивов**: Добавить префикс длины в полезную нагрузку.

---

## Требования к сборке

```ini
[env:nucleo_f411re]
platform = ststm32
board = nucleo_f411re
framework = stm32cube

board_build.link_flags =
    --specs=nosys.specs
    --specs=nano.specs

build_flags =
    -DUSE_HAL_DRIVER
    -DSTM32F411xE
    -std=c++17
    -mcpu=cortex-m4
    -mthumb
    -mfpu=fpv4-sp-d16
    -mfloat-abi=hard
    -I$PROJECT_DIR/include
    -I$PROJECT_DIR/lib/FreeRTOS/include
    -I$PROJECT_DIR/lib/FreeRTOS/portable/GCC/ARM_CM4F

build_unflags =
    -mfloat-abi=soft
    -mfloat-abi=softfp
    -mfloat-abi=hard
    -mfpu=*

lib_extra_dirs = $PROJECT_DIR/lib
lib_archive = no
```

---

## Заключение

Проект представляет собой полноценную реализацию **RPC-протокола через UART** для STM32F411RE с интеграцией **FreeRTOS** и использованием **C++17**:
- Реализован RPC-протокол через UART.
- Использована обработка в задачах FreeRTOS.
- Поддерживается кроссплатформенная сборка через PlatformIO.
- Предоставлены исходный код и документация.

Дизайн демонстрирует современные принципы embedded-разработки: **типобезопасность**, **модульность** и глубокое понимание низкоуровневых деталей (FPU, флаги компиляции). Будущие улучшения могут устранить текущие ограничения, сделав протокол ещё более надёжным и универсальным.