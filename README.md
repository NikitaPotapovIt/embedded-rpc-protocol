Конечно! Вот развернутое, структурированное описание для такого проекта, идеально подходящее для размещения в файле `README.md` на GitHub. Оно написано в профессиональном ключе и highlights все ключевые аспекты вашей работы.

---

# Embedded RPC Protocol over UART

**Язык:** C (стандарт C11/C17)
**Платформа:** Любой микроконтроллер (ARM Cortex-M, AVR, ESP32, etc.)
**Интерфейс:** UART (Universal Asynchronous Receiver-Transmitter)
**RTOS:** FreeRTOS

## Оглавление

1.  [Обзор](#обзор)
2.  [Архитектура и реализация](#архитектура-и-реализация)
3.  [Структура проекта](#структура-проекта)
4.  [Сборка и использование](#сборка-и-использование)
5.  [Пример работы](#пример-работы)
6.  [Анализ протокола и предложения по улучшению](#анализ-протокола-и-предложения-по-улучшению)
7.  [Недостатки исходного протокола](#недостатки-исходного-протокола)

## Обзор

Данный проект представляет собой программную реализацию упрощенного RPC (Remote Procedure Call) протокола для взаимодействия между микроконтроллерами или между микроконтроллером и хост-машиной по интерфейсу UART.

Протокол реализует многоуровневую архитектуру (по аналогии с OSI model), что обеспечивает четкое разделение ответственности и облегчает разработку, тестирование и модификацию:
*   **Физический уровень:** Драйвер UART.
*   **Канальный уровень:** Обрамление пакетов, контроль целостности данных с помощью CRC.
*   **Транспортный уровень:** Управление запросами/ответами, диспетчеризация вызовов функций.
*   **Уровень приложения:** API для регистрации пользовательских функций.

## Архитектура и реализация

### Многозадачность (FreeRTOS)
Система построена на основе RTOS для обеспечения надежного и предсказуемого приема/передачи данных без блокировок. Реализовано несколько задач:
*   `uart_rx_task`: Принимает сырые байты из UART (через очередь из прерывания).
*   `packet_parser_task`: Реализует конечный автомат (State Machine) для сборки пакетов из потока байт на Канальном уровне.
*   `rpc_processor_task`: Принимает собранные пакеты, парсит RPC-сообщения, ищет и исполняет зарегистрированные функции на Транспортном уровне.
*   `uart_tx_task`: (Опционально) Отправляет ответы в UART.

Для взаимодействия между задачами используются очереди FreeRTOS (`xQueue`), что обеспечивает потокобезопасность.

### Канальный уровень
Реализован в виде **конечного автомата (FSM)** для надежного выделения пакетов из асинхронного потока байт.
*   **Формат пакета:** `[0xFA][len_l][len_h][crc8_hdr][0xFB][data...][crc8_data][0xFE]`
*   **Контроль целостности:** Для проверки заголовка и данных используется алгоритм **CRC-8** (полином 0x7).
*   **Сброс состояния:** При любой ошибке (неверный CRC, неожиданный байт) автомат сбрасывается в состояние ожидания стартового байта `0xFA`, что позволяет быстро синхронизироваться с потоком данных после сбоя.

### Транспортный уровень (RPC)
*   **Диспетчер функций:** Реализована таблица зарегистрированных RPC-функций. Для поиска функции по её строковому имени используется `strcmp`.
*   **Типы сообщений:** Поддерживаются запрос (`0x0B`), поток (`0x0C`), ответ (`0x16`), ошибка (`0x21`).
*   **Механизм ответа:** Каждый запрос содержит порядковый номер (`N`), который копируется в ответ, что позволяет отправителю сопоставить запрос с ответом.
*   **Таймауты:** (Реализуется на стороне отправителя) Ожидание ответа ограничено по времени для избежания бесконечных блокировок.

## Структура проекта

```
src/
├── main.c                      # Инициализация HAL, RTOS, создание задач
├── phy_uart.c                  # Драйвер UART (низкоуровневый ввод/вывод, прерывания)
├── link_layer.c                # Конечный автомат, CRC, упаковка/распаковка пакетов
├── transport_layer.c           # Парсинг RPC, таблица функций, вызов
├── app_layer.c                 # Пользовательские RPC-функции
├── freertos.c                  # Конфигурация FreeRTOS
└── protocol.h                  # Общие константы, структуры данных
```

## Сборка и использование

1.  **Среды разработки:** Проект может быть собран с помощью STM32CubeIDE, PlatformIO или любой другой тулчейн, поддерживающей ARM-GCC.
2.  **Цель:** Код является кроссплатформенным. Для портирования на другой микроконтроллер необходимо переimplementить только `phy_uart.c` и `main.c` (инициализация периферии).
3.  **Сборка:**
    ```bash
    # Пример для PlatformIO
    pio run -t upload
    ```

## Пример работы

1.  **Хост отправляет запрос:** Вызов функции `"get_temp"` без аргументов.
    *   `Канальный у-нь -> [0xFA, 0x07, 0x00, 0xCR, 0xFB, 0x0B, 0x01, 'g','e','t','_','t','e','m','p', 0x00, 0xCR, 0xFE]`
    *   `Транспортный у-нь -> Тип: 0x0B (Запрос), N: 1, Имя: "get_temp", Аргументы: нет`

2.  **Устройство принимает и обрабатывает:**
    *   Канальный уровень проверяет CRC и извлекает данные.
    *   Транспортный уровень ищет "get_temp" в таблице, находит и вызывает функцию.
    *   Функция читает температуру и формирует результат (например, `25.5`).

3.  **Устройство отправляет ответ:**
    *   `Транспортный у-нь -> Тип: 0x16 (Ответ), N: 1, Данные: {25.5}`
    *   `Канальный у-нь -> [0xFA, 0x05, 0x00, 0xCR, 0xFB, 0x16, 0x01, ...(данные температуры)..., 0xCR, 0xFE]`

## Анализ протокола и предложения по улучшению

Исходный протокол является работоспособным, но имеет ряд недостатков с точки зрения эффективности и надежности.

### Недостатки исходного протокола

1.  **Низкая эффективность:** Высокие накладные расходы из-за множества служебных байт (`0xFA`, `0xFB`, `0xFE`, 2xCRC8). Для коротких команд полезная нагрузка может составлять < 30% от общего пакета.
2.  **Уязвимость к сбоям:** Служебные байты не экранируются. Если данные полезной нагрузки содержат `0xFA`, `0xFB` или `0xFE`, это приведет к рассинхронизации парсера и потере пакета.
3.  **Слабый контроль целостности:** CRC8 недостаточен для надежного обнаружения ошибок в пакетах длиннее нескольких байт. Рекомендуется использовать CRC16 или CRC32.
4.  **Неэффективный парсинг:** Использование строковых имен для идентификации функций требует операций `strcmp`, которые медленнее и потребляют больше памяти, чем работа с числовыми ID.

### Предложения по улучшению (v2.0)

1.  **Экранирование служебных байт (Byte Stuffing):**
    *   Ввести символ экранирования (e.g., `0xFD`).
    *   Вместо байта `0xFA` в данных передавать последовательность `0xFD 0x01`.
    *   Это устранит главную уязвимость и сделает протокол надежным.

2.  **Бинарные идентификаторы функций:**
    *   Заменить строку `name` на 2-байтный `function_id`.
    *   Это ускорит диспетчеризацию (поиск по индексу вместо строки) и сократит размер пакета.

3.  **Усиление контроля целостности:**
    *   Заменить CRC8 на CRC16 (например, CRC-16-CCITT) для всего пакета. Одной проверки достаточно.

4.  **Оптимизация формата пакета:**
    *   Убрать лишние служебные байты. Например, можно обойтись одним стартовым байтом и CRC16.
    *   **Предлагаемый формат:** `[0xFA][len][function_id][type][N][data...][crc16]`

5.  **Введение номеров версий:**
    *   Добавить поле `version` в заголовок для обеспечения обратной совместимости в будущем.

6.  **Механизм подтверждения (ACK/NACK):**
    *   Реализовать на канальном уровне подтверждение получения корректного пакета (ACK) или запрос повторной отправки при ошибке (NACK). Это повысит надежность передачи в зашумленных средах.

---
